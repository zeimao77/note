特点：
1.去中心化
2.财产匿名化

###########################
帐本如何验证？
少数服务多数？比较量太大，不般不使用
那么区块链又是如何验证的呢？
Hash函数：hash(原始信息) = 摘要信息
Hash函数特点：
1.同样的原始信息用同一个哈希函数总能得到相同的摘要的信息
2.原始信息任何微小和变量都引哈希出不同的摘要信息
3.从摘要信息无法逆向推算原始信息
第一个区块：{
	
Hash(
[
  {
    "账号": "ADFA",
    "收入": 100,
    "支出": 0,
    "余额": 200
  },
  {
    "账号": "ACCA",
    "收入": 300,
    "支出": 0,
    "余额": 200
  },
  {
    "账号": "ADDA",
    "收入": 0,
    "支出": 400,
    "余额": 200
  }
]
)= 787635a

}

第二个区块
Hash(787635a,新账本) = 456635b
这样每一个区块都包含上一区块的hash  当前账本摘要信息正确说明以前几本都是正确的
[区块0] <-- [区块1] <-- [区块2] <-- [区块3] <-- [区块4] <-- [区块5]
这样就形成了一个区块链


###########################
帐户的所有权  比特币系统
转账：
{
  "付款地址": "a369545d54dser6",
  "收款地址": "65s45e5rd5safrfdas",
  "金额": "6.6btc"
}
地址包含私钥 谁有私钥谁就对账号具有所有权  所以一定要保证私钥的安全
地址:a369545d54dser6
私钥：a45asd54ds5a5dads2a3asd5dasa1
地址 = Hash(Hash(fun(私钥)))
私钥可以推导出地址，而地址不可以推导出私钥  所以不可以使用账号更改私钥

如何验证交易的有效性呢？  签名  验证签名
hash(
{
  "付款地址": "a369545d54dser6",
  "收款地址": "65s45e5rd5safrfdas",
  "金额": "6.6btc"
}
) = 8adb23cdea6
签名操作必需在安全环境操作
签名：sign("8adb23cdea6","私钥：a45asd54ds5a5dads2a3asd5dasa1") = "3sd1f65dsa65ad"
签名信息 = sign(hash(转账记录),私钥)
验证：verify(签名信息,付款地址) = hash(转账)  利用此公式验证转账的有效性
if(verify("3sd1f65dsa65ad","a369545d54dser6") == hash({
  "付款地址": "a369545d54dser6",
  "收款地址": "65s45e5rd5safrfdas",
  "金额": "6.6btc"
})) {
	#入账
	#广播
}else {
	#处理
}

如果验证通过广播
所以区块链不会记录个人信息   也无法通过账号匹配到个人 



###########################
挖矿
记录规则 ：
1.一段时间内只有一个机器可以记账成功
2.通过解决密码学难题（工作量证明POW）竞争获得唯一的记账权
3.其他结果复制记账结果
工作量证明：
hash(上一个区块hash,交易记录集) = 456635bcd
hash(上一个区块hash,交易记录集,随机数) = 000000afd6356ad 
当前算例前面18个零   即16^18算例
记录交易记录集过程
1.收集广播中没有被记账的交易
2.验证交易的有效性
3.添加一笔给自己的转账交易（挖矿奖励）



###########################
共识机制
如果有两个节点同时完成了工作量证明，使用谁的区块呢？
总是选择更长的链作为主链
[#3456] <-- [#3457] <-- [#3458a]
                      |-[#3458b] <-- [#3459]
3459b链更长，所以会选择b链作为主链
区块间隔时间更短会使交易更快的确认完成但会生成更多的区块 也会产生更多的分叉
区块间隔时间更长会使交易确认变慢 分叉会更少
超过50%机器认同的区块则是有效的